# -*- coding: utf-8 -*-
"""Rekomendasi Film.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NTPz_RuSppk4mhkiyhS0yx11hxaEHqwp

# Penyusun

*   Nama  : Zhafran Pradistyatama Kuncoro
*   Email : zhafrankuncoro@gmail.com
*   ID DICODING: zhafrankuncoro / MC223D5Y0339
*   Link Dataset: [Dataset Film](https://www.kaggle.com/datasets/sayan0211/movie-recomendation-pjct/data)

# 1. Import Library
Pada bagian ini, dilakukan import berbagai library yang akan digunakan dalam proses pengolahan data, eksplorasi, pemodelan, hingga evaluasi model.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import csr_matrix
import seaborn as sns

"""# 2. Dataset

## 2.1 Mengunduh Dataset di Kaggle
"""

# Import module yang disediakan google colab untuk kebutuhan upload file
from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

# Ubah permission
!chmod 600 ~/.kaggle/kaggle.json

"""Perintah-perintah ini digunakan untuk menyiapkan file kaggle.json di lingkungan Google Colab agar Anda dapat menggunakan Kaggle API untuk mengunduh dataset atau berinteraksi dengan Kaggle.


"""

# Unduh file zip
!kaggle datasets download -d sayan0211/movie-recomendation-pjct

# Ubah perintah unzip
!unzip /content/movie-recomendation-pjct.zip -d movie-dataset

"""Perintah-perintah ini digunakan untuk mengunduh dan mengekstrak dataset dari Kaggle di Google Colab.

## 2.2 Load Dataset

Karena kita ingin membangund model content based filtering, maka kita hanya menggunakan dataset movies.csv
"""

film = pd.read_csv('/content/movie-dataset/movies.csv')
film.head()

"""# 3. Data Understanding"""

# Menampilkan Dataset
film

# Menampilkan rinfkasan dataset
film.info()

# Menampilkan statistik deskriptif
film.describe()

# Mengecek apakah ada missing value
film.isnull().sum()

film.duplicated().sum()

# Mengecek apakah terdapat data yang duplicated pada film
film.duplicated('title').sum()

# menampilkan dataset duplikat yang  berada di dkolom title

film[film.duplicated('title', keep=False)]

# Melihat jumlah genres
genre_counts_ringkas = film['genres'].str.split('|').explode().value_counts()

# Menampilkan jumlah genre
genre_counts_ringkas

# 1. Atur tema dan ukuran plot
sns.set_theme(style="whitegrid")
plt.figure(figsize=(12, 8))

# 2. Buat bar plot dengan Seaborn
ax = sns.barplot(x=genre_counts_ringkas.values, y=genre_counts_ringkas.index, palette="viridis", orient='h')

# 3. Tambahkan judul dan label
ax.set_title('Jumlah Film Berdasarkan Genre', fontsize=16)
ax.set_xlabel('Jumlah Film', fontsize=12)
ax.set_ylabel('Genre', fontsize=12)

# 4. Tampilkan plot
plt.tight_layout()
plt.show()

"""## Insight

* Dataset Movies memiliki 3 kolom dan 9742 baris
* Missing Value: Tidak terdapat missing value pada dataset
* Data Duplikat: Jika kita lihat pada awal pengecekan tidak ada data yang duplikat, akan tetapi jika kita cek di kolom 'title' terdapat 5 baris data yang duplikat, mengatasi duplikat dapat di drop saja karna jumlah nya hanya sedikit.
* Genre terbanyak pada dataset ini adalah Drama dan di ikuti oleh comedy, thtriller, actiom dst (dapat dilihat pada grafik/ tabel)
* Akan menggunakan kolom genre dan title, kolom movieid tidak akan digunakan karena kita akan melakukan rekomendasi berdasarkan genre
* Pada kolom genre masih terpisahkan dengan '|' kita akan membuat menjadi list seperti ini Contohnya, 'Action|Adventure|Sci-Fi' akan menjadi ['Action', 'Adventure', 'Sci-Fi']. Tujuannya agar melakukan one hot encoding lebih mudah.

# 3. Data Preparation

# 3.1 Mengatasi masalah
"""

# Drop data duplikat yang ada di kolom 'title'
film = film.drop_duplicates('title')
len(film)

# Memilih hanya kolom 'title' dan 'genres'
film_final = film[['title', 'genres']]

# Menampilkan 5 baris pertama dari subset
film_final.head()

"""## 3.2 Melakukan one hot encoding"""

# Pisahkan genre menjadi list
film_final['genres'] = film_final['genres'].str.split('|')

# Identifikasi genre unik
all_genres = set()
for genres in film_final['genres']:
    all_genres.update(genres)
all_genres = sorted(list(all_genres))  # Urutkan untuk konsistensi

# Fungsi untuk membuat vektor one-hot encoding
def genres_to_vector(genres):
    return [1 if genre in genres else 0 for genre in all_genres]

# Terapkan one-hot encoding
film_final['genre_vector'] = film_final['genres'].apply(genres_to_vector)

film_final

"""# 4. Model"""

# Konversi genre_vector ke sparse matrix untuk efisiensi
genre_matrix = np.array(list(film_final['genre_vector']))
sparse_genre_matrix = csr_matrix(genre_matrix)

"""## 4.1 Rekomendasi Berdasarkan Input Film"""

# Fungsi untuk merekomendasikan film
def recommend_movies(movie_title, df, genre_matrix, top_n=5):
    try:
        # Cari indeks film yang dipilih
        movie_idx = df[df['title'] == movie_title].index[0]

        # Ambil vektor genre dari film yang dipilih
        movie_vector = genre_matrix[movie_idx]

        # Hitung cosine similarity dengan semua film
        similarities = cosine_similarity(movie_vector, genre_matrix)[0]

        # Dapatkan indeks film dengan kemiripan tertinggi
        similar_indices = similarities.argsort()[-top_n-1:-1][::-1]  # Ambil top_n, abaikan film itu sendiri

        # Kembalikan judul, genre, dan skor kemiripan
        recommendations = df.iloc[similar_indices][['title', 'genres']].copy()
        recommendations['similarity_score'] = similarities[similar_indices]

        return recommendations
    except IndexError:
        return f"Film '{movie_title}' tidak ditemukan di dataset."

# Contoh penggunaan
movie_title = "Jumanji (1995)"
print(f"Rekomendasi untuk '{movie_title}':")
recommendations = recommend_movies(movie_title, film_final, sparse_genre_matrix, top_n=10)
recommendations

"""## 4.2 Rekomendasi Berdasarkan Input Genre"""

# Fungsi rekomendasi Berdasarkan genre
def recommend_movies_by_genres(input_genres, df, genre_matrix, all_genres, top_n=5, exact_match=False):
    try:
        # Ubah input genre menjadi list (misalnya, "Action, Comedy" -> ["Action", "Comedy"])
        input_genres = [genre.strip() for genre in input_genres.split(',')]

        # Validasi genre
        invalid_genres = [genre for genre in input_genres if genre not in all_genres]
        if invalid_genres:
            return f"Genre tidak valid: {invalid_genres}. Genre yang tersedia: {all_genres}"

        # Buat vektor one-hot encoding untuk input genre
        input_vector = np.array([[1 if genre in input_genres else 0 for genre in all_genres]])

        # Hitung cosine similarity antara input dan semua film
        similarities = cosine_similarity(input_vector, genre_matrix)[0]

        # Jika exact_match=True, hanya rekomendasikan film yang mengandung semua genre input
        if exact_match:
            mask = df['genres'].apply(lambda x: all(genre in x for genre in input_genres))
            if not mask.any():
                return f"Tidak ada film yang mengandung semua genre: {input_genres}"
            similar_indices = similarities[mask].argsort()[-top_n:][::-1]
            recommendations = df[mask].iloc[similar_indices][['title', 'genres']].copy()
            recommendations['similarity_score'] = similarities[mask][similar_indices]
        else:
            # Ambil top_n film dengan kemiripan tertinggi
            similar_indices = similarities.argsort()[-top_n:][::-1]
            recommendations = df.iloc[similar_indices][['title', 'genres']].copy()
            recommendations['similarity_score'] = similarities[similar_indices]

        return recommendations
    except Exception as e:
        return f"Terjadi kesalahan: {str(e)}"

# Rekomendasi Berdasarkan genre
input_genres = "Adventure, Children, Fantasy"
print(f"\nRekomendasi untuk genre: {input_genres}")
recommendations_by_genres = recommend_movies_by_genres(input_genres, film_final, sparse_genre_matrix, all_genres, top_n=10, exact_match=False)
recommendations_by_genres

"""# Evaluasi

* Rekomendasi pertama: Menghasilkan output yang memuaskan dan sesuai dengan input judul film

* Rekomendasi kedua: Menghasilkan output yang memuaskan dan sesuai dengan input genre
"""